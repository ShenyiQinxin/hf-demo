name: Build, Push & Deploy

on:
  push:
    branches: [ main ] # when you push to main
    tags: [ 'v*.*.*' ] # when you push a tag like v1.2.3
  workflow_dispatch: {} # also allow manual runs

jobs:
  build:
    runs-on: ubuntu-latest # runs on the latest Ubuntu VM
    permissions: # Grant the job 
      contents: read # read access for checkout
      packages: write # write access to GHCR

    env:
      IMAGE: ghcr.io/${{ github.repository }} # e.g. ghcr.io/shenyiqinxin/hugging-face-demo
    outputs:
      image_ref: ${{ steps.out.outputs.image_ref }} 

    steps:
      # (0) Checkout the code
      - uses: actions/checkout@v4 

      # (1) Docker login to GHCR with a temporary token, so we can push images
      - name: Log in to GHCR 
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # (2) Enable cross-arch CPU emulation so we can build arm64 images on amd64 runners (and vice versa)
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      # (3) Set up Docker Buildx driver for multi-arch builds
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # (4) Generate Docker image metadata (tags, labels) based on the pushed git refs
      - name: Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}

      # (5) Build & push multi-arch image (amd64, arm64)
      - name: Build and push (multi-arch)
        id: buildpush
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          platforms: linux/amd64,linux/arm64
          # Pushes it to ghcr with tags/labels from metadata step
          tags: ${{ steps.meta.outputs.tags }}  
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha # uses GitHub Actions cache as a cache source for faster builds
          cache-to: type=gha,mode=max # pushes the build cache to GitHub Actions
          # Hide the "unknown/unknown" attestation in GHCR listings (optional)
          provenance: false

      # Debug: show the digest that Buildx returned (should be sha256:...)
      - name: Show build digest (debug)
        run: echo "buildpush.digest='${{ steps.buildpush.outputs.digest }}'"

      # (6) After push, docker export an immutable digest reference to the image, e.g. sha256:...
      # This stores the sha256 in the job output "image_ref", which is used the exact inage by the deploy job
      - name: Export image ref (by digest)
        id: out                                     # <-- REQUIRED id
        run: |
          DIGEST='${{ steps.buildpush.outputs.digest }}'
          if [ -z "$DIGEST" ]; then
            echo "ERROR: Buildx did not return a digest. Did the build step have id: buildpush and push: true?" >&2
            exit 1
          fi
          echo "image_ref=${{ env.IMAGE }}@${DIGEST}" >> "$GITHUB_OUTPUT"
          echo "Published image_ref='${{ env.IMAGE }}@${DIGEST}'"

  # =========================
  # OPTION A: SELF-HOSTED RUNNER (deploys to your local cluster)
  # - Run a self-hosted runner on your Mac (where Rancher Desktop/minikube/k3d runs)
  # - No kubeconfig secret needed; it uses your local ~/.kube/config and network
  # =========================
  deploy-selfhosted:
    # set to needs.build.result == 'success' if you want stricter gating
    if: ${{ needs.build.result == 'success' }} 
    needs: build # runs after build job
    runs-on: [self-hosted, macOS, X64, local-k8s]   #  you set on your runner
    environment: dev
    timeout-minutes: 10
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4 # Checkout the code for manifests

      - name: Show resolved image (debug)
        run: |
          echo "IMG='${{ needs.build.outputs.image_ref }}'"
          if [ -z "${{ needs.build.outputs.image_ref }}" ]; then
            echo "ERROR: image_ref from build is empty." >&2
            exit 1
          fi
      - name: Ensure kubeconfig
        run: echo "KUBECONFIG=$HOME/.kube/config" >> $GITHUB_ENV

      - name: kubectl version (sanity) # sanity check that kubectl is installed
        run: kubectl version --client=true 

      - name: Apply K8s manifests # Apply the manifests and ensure they exist
        run: |
          kubectl apply -f k8s/namespace.yaml
          kubectl apply -f k8s/

      - name: Set image & wait for rollout
        env:
          IMG: ${{ needs.build.outputs.image_ref }} # get the image ref from build job output
        run: |
          # Double check again that IMG is not empty
          [ -n "$IMG" ] || { echo "IMG is empty"; exit 1; }
          kubectl -n hf-demo set image deploy/hugging-face-demo app="$IMG"
          kubectl -n hf-demo rollout status deploy/hugging-face-demo --timeout=120s

  # =========================
  # OPTION B: HOSTED RUNNER WITH KUBECONFIG SECRET (deploys to a reachable cluster)
  # - Use this if your cluster API is reachable from the internet/VPN
  # - Add repo secret KUBE_CONFIG_B64 = base64 of a kubeconfig scoped to namespace hf-demo
  # =========================
  # deploy-hosted:
  #   needs: build
  #   runs-on: ubuntu-latest
  #   environment: production
  #   steps:
  #     - uses: actions/checkout@v4
  #     - name: Write kubeconfig from secret
  #       run: |
  #         echo "${{ secrets.KUBE_CONFIG_B64 }}" | base64 -d > "$HOME/.kubeconfig"
  #         chmod 600 "$HOME/.kubeconfig"
  #         echo "KUBECONFIG=$HOME/.kubeconfig" >> $GITHUB_ENV
  #
  #     - name: Install kubectl
  #       uses: azure/setup-kubectl@v4
  #       with:
  #         version: 'latest'
  #
  #     - name: Apply K8s manifests
  #       run: |
  #         kubectl apply -f namespace.yaml
  #         kubectl apply -f service.yaml
  #         kubectl apply -f deployment.yaml
  #         kubectl apply -f ingress.yaml
  #
  #     - name: Set image & wait for rollout
  #       env:
  #         IMG: ${{ needs.build.outputs.image_ref }}
  #       run: |
  #         kubectl -n hf-demo set image deploy/hugging-face-demo app="$IMG"
  #         kubectl -n hf-demo rollout status deploy/hugging-face-demo --timeout=120s